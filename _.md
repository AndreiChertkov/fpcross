# fpcross
> Solution of the multidimensional Fokker-Planck equation (FPE) by fast and accurate tensor based methods with cross approximation in the tensor-train (TT) format
- QUES Можно ли сделать конвекцию в рамках интерполяционного тензора? Если да, то для последующего интегрирования не потребуется заново считать интерполянт
- QUES Можно ли вычислять интерполянт не в отдельных точках, а сразу на некоторой смещенной тензорной сетке? Видимо - нет
- QUES Зачем нужна J0
- QUES Зачем нужно интегрирование

- Уточнить в Алгоритме 2 и 4 нужно ли округление

## git
- Github: [fpcross](https://github.com/AndreiChertkov/fpcross)
## jupyter
## python
## colab
- Notebook:
  - Link: [fpcross_np](https://colab.research.google.com/drive/1-1atifKoTE8nNSggsD42KFr28xk6MqIj?usp=sharing)
  - Rights: Anyone on the internet with this link can view
- Notebook:
  - Link: [fpcross_tt](https://colab.research.google.com/drive/19IfqOoexSr42xo_GCV3eZZpvTYg2YJhw?usp=sharing)
  - Rights: Anyone on the internet with this link can view
- Notebook:
  - Link: [fpcross_nb](https://colab.research.google.com/drive/1-bncDpvwyIsCZNw3zwUKV_anbFij_OmN?usp=sharing)
  - Rights: Anyone on the internet with this link can view
- Notebook:
  - Link: [fpcross_ja](https://colab.research.google.com/drive/1ERMfL6ecs_iYssKpVJS4HqVwCzXC9BQn?usp=sharing)
  - Rights: Anyone on the internet with this link can view
- Notebook:
  - Link: [fpcross_pt](https://colab.research.google.com/drive/1TmfeRV3yQbeESvDHG5pEOcFUDTsW_lHt?usp=sharing)
  - Rights: Anyone on the internet with this link can view
- Notebook:
  - Link: [fpcross_all](https://colab.research.google.com/drive/18UcW4_4jNDYPK4pnxtAcmh8rWDcGvkHG?usp=sharing)
  - Rights: Anyone on the internet with this link can view
## 2020/09/09/maoutsa2020interacting
> Статья
## .gitattributes
## .gitignore
## build
> Вспомогательная служебная папка для создания python-пакета
## computations
> Разные старые расчеты (устаревшая папка)
## dist
> Вспомогательная служебная папка для создания python-пакета
## examples
> Jupyter ноутбуки с примерами использования fpcross (нужно обновить)
## fpcross
> Программный код
- Скрипт для запуска `python setup.py install && python ./tests/test.py`
- [ ] TODO Add convention about init/prep/calc to the README file
- [ ] TODO Add kwargs support (not only opts) for init functions in all classes
- [ ] TODO Add color dict and generate css, using color names in config file
- [ ] TODO Maybe move css into separate .css file in config file
- [ ] TODO Remove config['plot'] in config file
- [ ] TODO Check formula for Chebyshev differential matrix (why we need $J$ matrix)
### `func.py`
#### Func
- Class for the fast interpolation of multidimensional function by Chebyshev polynomials in the dense (numpy) or sparse (tensor train (TT) with cross approximation) format using Fast Fourier Transform (FFT)
- [ ] TODO Add computation of compression TT-factors to res

## fpcross.egg-info
> Вспомогательная служебная папка для создания python-пакета
## LICENSE.txt
> Текст лицензии пакета
## MANIFEST.in
> Вспомогательный файл для создания python-пакета
## package
> Папка с различными альтернативными интересными пакетами (устаревшее)
## paper
- https://www.overleaf.com/project/5fd1de5f331b0f4678c0e9e0
### dmsuite-master
> Использовал матрицы D из кода данной библиотеки
### ttvibr
> Библиотека Максима Рахубы, Иван советовал что-то из нее взять

## README.md
## results_for_paper_fpcross
> Папка с ноутбуком для построения графиков для научной статьи по теме проекта
## setup.cfg
> Файл конфигурации для пакета
## setup.py
> Установочный файл для пакета
- Отличный пример оформления https://github.com/pypa/sampleproject
## tests
> Тесты для пакета (с использованием библиотеки unittest)
## text
> Старые (неупорядоченные) статьи по теме
## tmp
- [Simple-SDE-solver](https://github.com/lmount/Simple-SDE-solver/blob/master/solve_sde.py)
  > Простеший (50 строк) решатель SDE на python
- [Discrete Chebyshev transform](https://en.wikipedia.org/wiki/Discrete_Chebyshev_transform)
  > Компактная теория по построению Чебышевского интерполянта
- [The FFT in Chebfun](https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/23972/versions/22/previews/chebfun/examples/approx/html/ChebfunFFT.html)
  > Описание на примере работы FFT
- [Learning SDEs in Python](https://www.quantopian.com/posts/learning-sdes-in-python)
  > Jupyter notebook (и ссылка на лекцию), демонстрирующие принципы работы с SDE
- [On Solving Partial Differential Equations with Brownian Motion in Python](https://srome.github.io/On-Solving-Partial-Differential-Equations-with-Brownian-Motion-in-Python/)
  > Интересная статья, где демонстрируется связь SDE с PDE
- [The Fokker-Planck Equation](http://www.math.wisc.edu/~shottovy/NumPDEreport.pdf)
  > Сравнение методов конечных разностей и конечных элементов для решения FPE
- [chebpy](https://github.com/chebpy/chebpy)
  > Реализация Chebfun на python
### Current_state

Иван, привет!

В общем, резюме по fpcross.

- Текст статьи и все расчеты, в принципе, готовы (?), однако остался ряд незакрытых вопросов (см. ниже).

- Текст статьи находится в репо https://github.com/AndreiChertkov/paper_fpcross, также ниже пересылаю pdf-ку. Текст стабилен (то есть формально - это завершенная статья).

- Репозиторий с кодом здесь https://github.com/AndreiChertkov/fpcross, но сам код там не актуальный. В README есть ссылки на открытые актуальные colab ноутбуки с различными реализациями кода (numpy, tt, numba, jax, pytorch): tt - это базовая реализация кода (в TT-формате); numpy - это эквивалентная реализация в полном формате (актуальна для 1D задачи); остальное - мои попытки ускорить код (в итоге не особо успешные, хотя, например, версия pytorch полностью как-бы рабочая на GPU, но гораздо более медленная, чем базовая).

- Специально сделал код в colab, причем делал множество итераций по его "компактификации". Текущая версия - это эталон (в моем понимании) - проще и компактнее невозможно. Комментариев к функциям нет (убрал их для компактности), но названия, вроде, самообъясняющие. Соответственно, если ошибки вдруг есть, то их легко обнаружить.

Ниже актуальные вопросы по fpcross.

1. Потеря нормировки.

В рамках сплиттинг-схемы 2-ого порядка после решения конвекционной части у меня теряется нормировка PDF. Приходится на каждой итерации перенормировать (для интегрирования я использую не явную квадратуру, а метод из книги Trefethen: вычисляю тензор коэффициентов интерполянта решения конв. части в TT-формате, а затем суммирую определенным образом элементы этого тензора - работает корректно и вроде быстро).

Гипотеза, почему так происходит - когда я вычисляю в рамках конвекции значения интерполянта, я зануляю точки, попавшие вне пределов сетки, может дело в этом (проверить, наверное, можно, взяв существенно бОльшие min/max для сетки, но что-то ничего особо вроде не изменилось при проверке, так что гипотеза похоже неверна).

Вообще говоря, это (дополнительное интегрирование) вроде как не повышает сложность алгоритма, поскольку основная сложность (время) приходится на вычисление интерполянта в "прообразах запрашиваемых крестом точек" (см. след. пункт).

То есть проблемы в этом нет вроде, но в тексте статьи я не пишу про это дополнительное интегрирование (перенормировку). Нужно ли что-то предпринять?

2. Медленность вычисления значений интерполянта.

В рамках решения уравнения конвекции, я вычисляю значения проинтерполированного решения диффузионной части в "прообразах запрашиваемых крестом точек". На каждой итерации креста запрашивается набор точек, и я вынужден в цикле для каждой точки вычислять значение интерполянта, в том числе проверять, не выходит ли точка за пределы сетки.

Это очень медленно. При расчетах бОльшая часть времени тратится именно на операцию вычисления значений интерполянта. Я хотел это как-то исправить. Хотя бы ускорить "неэффективный python код в рамках цикла".

Пробовал numba, но из-за необходимости перекомпилировать функцию на каждом шаге по времени (поскольку меняются ядра тензора коэффициентов, в частности, меняется их shape, то есть кеширование не работает), особого выигрыша в производительности нет.

Пробовал jax - ничего интересного не вышло.

Пробовал pytorch + tntorch. Полностью переписал код под это дело (все сидит на GPU). Но работает существенно медленее, чем исходный вариант. Возможно я что-то сделал не так.

В итоге, ускорить код не получилось. В идеале, мне хотелось бы конечно разобраться (с твоей помощью?), почему моя реализация pytorch + tntorch работает медленно, может ли (должен ли) она работать быстро, и все ли я делаю правильно.

3. Нет теоретических оценок на точность / сложность.

Не знаю, нужны ли они. Если да, то надо прежде уточнить, в частности, первый пункт (дополнительное интегрирование). Совершенно также не понятно, как оценивать сложность креста в нашем случае (она зависит от рангов получаемого тензора, которые не понятно, от чего могут зависеть).

4. Нет эмпирических оценок на точность.

Поскольку реализовал я текущую версию в colab, а ввиду пункта 2 работает все не быстро, то запустить расчеты для множества разных шагов сетки по времени и в пространстве (для оценки порядка точности) не особо получается. Это тогда нужно на чем-то более мощном считать... Нужно ли?

### also

- [fpcross_nb](https://colab.research.google.com/drive/1-bncDpvwyIsCZNw3zwUKV_anbFij_OmN?usp=sharing);
  > Basic code sped up using numba python package (draft!).
- [fpcross_ja](https://colab.research.google.com/drive/1ERMfL6ecs_iYssKpVJS4HqVwCzXC9BQn?usp=sharing);
  > Code implementation using jax python package (GPU implementation; draft!).
- [fpcross_pt](https://colab.research.google.com/drive/1TmfeRV3yQbeESvDHG5pEOcFUDTsW_lHt?usp=sharing);
  > Code implementation using pytorch, tntorch and torchdiffeq python packages (GPU implementation; draft!).
- [fpcross_all](https://colab.research.google.com/drive/18UcW4_4jNDYPK4pnxtAcmh8rWDcGvkHG?usp=sharing).
  > ...
